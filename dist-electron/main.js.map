{
  "version": 3,
  "sources": ["../electron/main.ts"],
  "sourcesContent": ["import { app, BrowserWindow, ipcMain, protocol } from \"electron\";\nimport * as path from \"path\";\nimport * as fs from \"fs/promises\";\nimport { exec } from \"child_process\";\nimport { promisify } from \"util\";\nimport { fileURLToPath } from \"url\";\nimport { createRequire } from \"module\";\n\nconst require = createRequire(import.meta.url);\nconst ffmpegStatic = require(\"ffmpeg-static\");\n\nconst execAsync = promisify(exec);\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconst isDev = process.env.NODE_ENV === \"development\" || !app.isPackaged;\n\nlet mainWindow: BrowserWindow | null = null;\n\n// Function to get mounted volumes (macOS and Linux)\nasync function getMountedVolumes(): Promise<string[]> {\n  try {\n    if (process.platform === \"darwin\") {\n      // macOS: Check /Volumes directory\n      const volumes = await fs.readdir(\"/Volumes\");\n      return volumes.map((vol) => `/Volumes/${vol}`);\n    } else if (process.platform === \"linux\") {\n      // Linux: Check /media and /mnt\n      const volumes: string[] = [];\n      try {\n        const media = await fs.readdir(\"/media\");\n        volumes.push(...media.map((vol) => `/media/${vol}`));\n      } catch {\n        // /media may not exist or be accessible\n      }\n      try {\n        const mnt = await fs.readdir(\"/mnt\");\n        volumes.push(...mnt.map((vol) => `/mnt/${vol}`));\n      } catch {\n        // /mnt may not exist or be accessible\n      }\n      return volumes;\n    } else if (process.platform === \"win32\") {\n      // Windows: Get drive letters\n      const { stdout } = await execAsync(\"wmic logicaldisk get name\");\n      const drives = stdout\n        .split(\"\\n\")\n        .filter((line) => line.trim().match(/^[A-Z]:/))\n        .map((line) => line.trim());\n      return drives;\n    }\n    return [];\n  } catch (error) {\n    console.error(\"Error getting mounted volumes:\", error);\n    return [];\n  }\n}\n\n// Function to detect if a volume is removable (SD/CF card)\nasync function isRemovableMedia(volumePath: string): Promise<boolean> {\n  try {\n    if (process.platform === \"darwin\") {\n      // macOS: Use diskutil to check if it's removable\n      const volumeName = path.basename(volumePath);\n      try {\n        const { stdout } = await execAsync(`diskutil info \"${volumeName}\"`);\n        // Check if it's removable or external\n        return (\n          stdout.includes(\"Removable Media:\") ||\n          stdout.includes(\"External:\") ||\n          stdout.includes(\"Removable: Yes\") ||\n          volumeName.toLowerCase().includes(\"sd\") ||\n          volumeName.toLowerCase().includes(\"cf\")\n        );\n      } catch {\n        // If diskutil fails, check common SD/CF card names\n        const name = volumeName.toLowerCase();\n        return name.includes(\"sd\") || name.includes(\"cf\") || name.includes(\"card\");\n      }\n    } else if (process.platform === \"linux\") {\n      // Linux: Check sysfs for removable flag\n      const volumeName = path.basename(volumePath);\n      try {\n        const { stdout } = await execAsync(`findmnt -n -o SOURCE --target \"${volumePath}\"`);\n        const device = stdout.trim();\n        if (device) {\n          const deviceName = path.basename(device);\n          const removablePath = `/sys/block/${deviceName}/removable`;\n          try {\n            const removable = await fs.readFile(removablePath, \"utf-8\");\n            return removable.trim() === \"1\";\n          } catch {\n            // Fallback to name checking\n            const name = volumeName.toLowerCase();\n            return name.includes(\"sd\") || name.includes(\"cf\") || name.includes(\"card\");\n          }\n        }\n      } catch {\n        // findmnt may not be available or volume may not be mounted\n      }\n      // Fallback: check if name suggests SD/CF card\n      const name = volumeName.toLowerCase();\n      return name.includes(\"sd\") || name.includes(\"cf\") || name.includes(\"card\");\n    } else if (process.platform === \"win32\") {\n      // Windows: Check drive type\n      try {\n        const drive = volumePath[0];\n        const { stdout } = await execAsync(`wmic logicaldisk where \"name='${drive}:'\" get drivetype`);\n        // Drive type 2 = Removable\n        return stdout.includes(\"2\");\n      } catch {\n        // wmic may not be available or drive may not exist\n        return false;\n      }\n    }\n    return false;\n  } catch (error) {\n    console.error(`Error checking if ${volumePath} is removable:`, error);\n    return false;\n  }\n}\n\n// Function to get volume UUID/serial number\nasync function getVolumeUUID(volumePath: string): Promise<string | null> {\n  try {\n    if (process.platform === \"darwin\") {\n      // macOS: Use diskutil to get UUID\n      const volumeName = path.basename(volumePath);\n      try {\n        const { stdout } = await execAsync(`diskutil info \"${volumeName}\"`);\n        // Look for Volume UUID or Disk / Partition UUID\n        const uuidMatch =\n          stdout.match(/Volume UUID:\\s*([A-F0-9-]+)/i) || stdout.match(/Disk \\/ Partition UUID:\\s*([A-F0-9-]+)/i);\n        if (uuidMatch && uuidMatch[1]) {\n          return uuidMatch[1];\n        }\n        // Fallback: use volume name as identifier\n        return volumeName;\n      } catch {\n        // Fallback: use volume name as identifier\n        return volumeName;\n      }\n    } else if (process.platform === \"linux\") {\n      // Linux: Use findmnt to get UUID\n      try {\n        const { stdout } = await execAsync(`findmnt -n -o UUID --target \"${volumePath}\"`);\n        const uuid = stdout.trim();\n        if (uuid && uuid !== \"unknown\") {\n          return uuid;\n        }\n      } catch {\n        // Fallback: use volume name\n      }\n      return path.basename(volumePath);\n    } else if (process.platform === \"win32\") {\n      // Windows: Use wmic to get volume serial number\n      const drive = volumePath[0];\n      try {\n        const { stdout } = await execAsync(`wmic logicaldisk where \"name='${drive}:'\" get VolumeSerialNumber`);\n        const serialMatch = stdout.match(/VolumeSerialNumber\\s+([A-F0-9]+)/i);\n        if (serialMatch && serialMatch[1]) {\n          return serialMatch[1];\n        }\n      } catch {\n        // Fallback: use drive letter\n      }\n      return drive;\n    }\n    return path.basename(volumePath);\n  } catch (error) {\n    console.error(`Error getting UUID for ${volumePath}:`, error);\n    return path.basename(volumePath);\n  }\n}\n\n// Function to get volume info (path and UUID)\nasync function getVolumeInfo(volumePath: string): Promise<{ path: string; uuid: string } | null> {\n  const uuid = await getVolumeUUID(volumePath);\n  if (!uuid) return null;\n  return { path: volumePath, uuid };\n}\n\n// Function to detect SD/CF cards with volume info\nasync function detectSDCFCards(): Promise<Array<{ path: string; uuid: string }>> {\n  const volumes = await getMountedVolumes();\n  const cards: Array<{ path: string; uuid: string }> = [];\n\n  for (const volume of volumes) {\n    if (await isRemovableMedia(volume)) {\n      const info = await getVolumeInfo(volume);\n      if (info) {\n        cards.push(info);\n      }\n    }\n  }\n\n  return cards;\n}\n\n// Poll for SD/CF card insertion\nlet lastDetectedCards: Array<{ path: string; uuid: string }> = [];\nlet pollInterval: NodeJS.Timeout | null = null;\n\nasync function pollForCards() {\n  try {\n    const cards = await detectSDCFCards();\n\n    // Check for newly inserted cards (compare by UUID)\n    const newCards = cards.filter((card) => !lastDetectedCards.some((lc) => lc.uuid === card.uuid));\n\n    if (newCards.length > 0 && mainWindow) {\n      console.log(\"SD/CF card detected:\", newCards);\n      // Send event to renderer with both path and UUID\n      mainWindow.webContents.send(\"sd-card-detected\", newCards[0].path, newCards[0].uuid);\n    }\n\n    // Check for removed cards (compare by UUID)\n    const removedCards = lastDetectedCards.filter((lc) => !cards.some((card) => card.uuid === lc.uuid));\n    if (removedCards.length > 0 && mainWindow) {\n      console.log(\"SD/CF card removed:\", removedCards);\n      mainWindow.webContents.send(\"sd-card-removed\", removedCards[0].path, removedCards[0].uuid);\n    }\n\n    lastDetectedCards = cards;\n  } catch (error) {\n    console.error(\"Error polling for cards:\", error);\n  }\n}\n\nconst createWindow = () => {\n  // Create the browser window\n  const preloadPath = path.join(__dirname, \"preload.js\");\n  console.log(\"Loading preload script from:\", preloadPath);\n\n  mainWindow = new BrowserWindow({\n    width: 1200,\n    height: 800,\n    webPreferences: {\n      preload: preloadPath,\n      nodeIntegration: false,\n      contextIsolation: true,\n    },\n    titleBarStyle: process.platform === \"darwin\" ? \"hiddenInset\" : \"default\",\n  });\n\n  // Debug: Check if preload script exists\n  fs.access(preloadPath)\n    .then(() => console.log(\"\u2713 Preload script exists\"))\n    .catch(() => console.error(\"\u2717 Preload script NOT found at:\", preloadPath));\n\n  // Load the app\n  if (isDev) {\n    mainWindow.loadURL(\"http://localhost:5173\");\n    // Open DevTools in development\n    mainWindow.webContents.openDevTools();\n  } else {\n    mainWindow.loadFile(path.join(__dirname, \"../dist/index.html\"));\n  }\n};\n\n// IPC Handlers for file system operations\nipcMain.handle(\"fs:readDirectory\", async (_event, dirPath: string) => {\n  try {\n    const entries = await fs.readdir(dirPath, { withFileTypes: true });\n    const result = await Promise.all(\n      entries.map(async (entry) => {\n        const fullPath = path.join(dirPath, entry.name);\n        const stats = await fs.stat(fullPath);\n        return {\n          name: entry.name,\n          path: fullPath,\n          type: entry.isDirectory() ? \"folder\" : \"file\",\n          size: stats.size,\n          isDirectory: entry.isDirectory(),\n        };\n      })\n    );\n    return { success: true, data: result };\n  } catch (error) {\n    return { success: false, error: String(error) };\n  }\n});\n\n// Search files using macOS Spotlight (mdfind) - much faster than recursive directory reading\nipcMain.handle(\"fs:searchFiles\", async (_event, query: string, searchPath?: string) => {\n  try {\n    if (process.platform !== \"darwin\") {\n      return { success: false, error: \"mdfind is only available on macOS\" };\n    }\n\n    // Handle file extension queries using Spotlight query syntax\n    // mdfind uses Spotlight queries, not shell glob patterns\n    const searchPattern = query.trim();\n    console.log(\"searchFiles - original query:\", query, \"trimmed:\", searchPattern);\n    \n    // Build Spotlight query pattern\n    let spotlightQuery: string;\n    \n    if (searchPattern.startsWith(\".\")) {\n      // \".wav\" -> match files ending with .wav\n      // Remove the leading dot to get the extension\n      const ext = searchPattern.substring(1);\n      console.log(\"searchFiles - extension search, ext:\", ext);\n      \n      // Use kMDItemFSName with wildcard pattern - the 'c' flag makes it case-insensitive\n      // Escape the extension in case it has special characters, but keep it simple for common extensions\n      const escapedExt = ext.replace(/'/g, \"\\\\'\");\n      spotlightQuery = `kMDItemFSName == '*.${escapedExt}'c`;\n    } else {\n      // \"wav\" or other text -> match files containing the text\n      const escapedPattern = searchPattern.replace(/'/g, \"\\\\'\");\n      spotlightQuery = `kMDItemFSName == '*${escapedPattern}*'c`;\n    }\n    \n    console.log(\"searchFiles - spotlight query:\", spotlightQuery);\n    \n    // Build mdfind command using Spotlight query syntax\n    // The query is wrapped in double quotes, so single quotes inside are safe\n    let command: string;\n    if (searchPath) {\n      const escapedPath = searchPath.replace(/[\"\\\\]/g, \"\\\\$&\");\n      command = `mdfind -onlyin \"${escapedPath}\" \"${spotlightQuery}\"`;\n    } else {\n      command = `mdfind \"${spotlightQuery}\"`;\n    }\n    \n    console.log(\"mdfind command:\", command);\n\n    const { stdout, stderr } = await execAsync(command, { maxBuffer: 10 * 1024 * 1024 }); // 10MB buffer\n    \n    if (stderr && !stderr.includes(\"mdfind:\")) {\n      console.warn(\"mdfind stderr:\", stderr);\n    }\n\n    const filePaths = stdout\n      .split(\"\\n\")\n      .map((line) => line.trim())\n      .filter((line) => line.length > 0);\n\n    console.log(\"searchFiles - mdfind returned\", filePaths.length, \"file paths\");\n\n    // Get stats for each file to determine if it's a file or folder\n    const results = await Promise.all(\n      filePaths.map(async (filePath) => {\n        try {\n          const stats = await fs.stat(filePath);\n          return {\n            name: path.basename(filePath),\n            path: filePath,\n            type: stats.isDirectory() ? \"folder\" : \"file\",\n            size: stats.size,\n            isDirectory: stats.isDirectory(),\n          };\n        } catch (error) {\n          // File might have been deleted between mdfind and stat\n          return null;\n        }\n      })\n    );\n\n    // Filter out null results and hidden files/folders\n    const filteredResults = results.filter(\n      (result) => result && !result.name.startsWith(\".\") && !result.name.startsWith(\"~\")\n    ) as Array<{\n      name: string;\n      path: string;\n      type: \"file\" | \"folder\";\n      size: number;\n      isDirectory: boolean;\n    }>;\n\n    console.log(\"searchFiles - filtered results:\", filteredResults.length);\n\n    return { success: true, data: filteredResults };\n  } catch (error) {\n    return { success: false, error: String(error) };\n  }\n});\n\nipcMain.handle(\"fs:copyFile\", async (_event, sourcePath: string, destPath: string) => {\n  try {\n    // Ensure destination directory exists\n    const destDir = path.dirname(destPath);\n    await fs.mkdir(destDir, { recursive: true });\n    await fs.copyFile(sourcePath, destPath);\n    return { success: true };\n  } catch (error) {\n    return { success: false, error: String(error) };\n  }\n});\n\n// Helper function to check if a path is inside another path\nfunction isPathInside(parentPath: string, childPath: string): boolean {\n  const parent = path.resolve(parentPath);\n  const child = path.resolve(childPath);\n  const relative = path.relative(parent, child);\n  return relative !== \"\" && !relative.startsWith(\"..\") && !path.isAbsolute(relative);\n}\n\nasync function copyFolderRecursive(sourcePath: string, destPath: string, rootSourcePath: string): Promise<void> {\n  await fs.mkdir(destPath, { recursive: true });\n  const entries = await fs.readdir(sourcePath, { withFileTypes: true });\n\n  for (const entry of entries) {\n    const sourceEntryPath = path.join(sourcePath, entry.name);\n    const destEntryPath = path.join(destPath, entry.name);\n\n    // Skip if destination would be inside the source tree (prevents recursive copying)\n    if (isPathInside(rootSourcePath, destEntryPath)) {\n      continue;\n    }\n\n    if (entry.isDirectory()) {\n      await copyFolderRecursive(sourceEntryPath, destEntryPath, rootSourcePath);\n    } else {\n      await fs.copyFile(sourceEntryPath, destEntryPath);\n    }\n  }\n}\n\nipcMain.handle(\"fs:copyFolder\", async (_event, sourcePath: string, destPath: string) => {\n  try {\n    // Check if destination is inside source (prevent copying folder into itself)\n    if (isPathInside(sourcePath, destPath)) {\n      return { success: false, error: \"Cannot copy folder into itself or its subdirectories\" };\n    }\n\n    await copyFolderRecursive(sourcePath, destPath, sourcePath);\n    return { success: true };\n  } catch (error) {\n    return { success: false, error: String(error) };\n  }\n});\n\nipcMain.handle(\"fs:getFileStats\", async (_event, filePath: string) => {\n  try {\n    const stats = await fs.stat(filePath);\n    return {\n      success: true,\n      data: {\n        size: stats.size,\n        isDirectory: stats.isDirectory(),\n        isFile: stats.isFile(),\n      },\n    };\n  } catch (error) {\n    return { success: false, error: String(error) };\n  }\n});\n\nipcMain.handle(\"fs:getHomeDirectory\", () => {\n  return { success: true, data: app.getPath(\"home\") };\n});\n\nipcMain.handle(\"fs:getSDCFCards\", async () => {\n  try {\n    const cards = await detectSDCFCards();\n    return { success: true, data: cards };\n  } catch (error) {\n    return { success: false, error: String(error) };\n  }\n});\n\nipcMain.handle(\"fs:getVolumeInfo\", async (_event, volumePath: string) => {\n  try {\n    const info = await getVolumeInfo(volumePath);\n    if (!info) {\n      return { success: false, error: \"Could not get volume info\" };\n    }\n    return { success: true, data: info };\n  } catch (error) {\n    return { success: false, error: String(error) };\n  }\n});\n\nasync function deleteFolderRecursive(folderPath: string): Promise<void> {\n  const entries = await fs.readdir(folderPath, { withFileTypes: true });\n\n  for (const entry of entries) {\n    const fullPath = path.join(folderPath, entry.name);\n    if (entry.isDirectory()) {\n      await deleteFolderRecursive(fullPath);\n    } else {\n      await fs.unlink(fullPath);\n    }\n  }\n\n  await fs.rmdir(folderPath);\n}\n\nipcMain.handle(\"fs:deleteFile\", async (_event, filePath: string) => {\n  try {\n    await fs.unlink(filePath);\n    return { success: true };\n  } catch (error) {\n    return { success: false, error: String(error) };\n  }\n});\n\nipcMain.handle(\"fs:deleteFolder\", async (_event, folderPath: string) => {\n  try {\n    await deleteFolderRecursive(folderPath);\n    return { success: true };\n  } catch (error) {\n    return { success: false, error: String(error) };\n  }\n});\n\nipcMain.handle(\"fs:createFolder\", async (_event, folderPath: string) => {\n  try {\n    await fs.mkdir(folderPath, { recursive: true });\n    return { success: true };\n  } catch (error) {\n    return { success: false, error: String(error) };\n  }\n});\n\nipcMain.handle(\"fs:revealInFinder\", async (_event, filePath: string) => {\n  try {\n    if (process.platform === \"darwin\") {\n      // macOS: Use 'open -R' to reveal file in Finder\n      await execAsync(`open -R \"${filePath}\"`);\n    } else if (process.platform === \"win32\") {\n      // Windows: Use explorer to select the file\n      await execAsync(`explorer /select,\"${filePath.replace(/\\//g, \"\\\\\")}\"`);\n    } else {\n      // Linux: Use xdg-open to open parent directory\n      const parentDir = path.dirname(filePath);\n      await execAsync(`xdg-open \"${parentDir}\"`);\n    }\n    return { success: true };\n  } catch (error) {\n    return { success: false, error: String(error) };\n  }\n});\n\nipcMain.handle(\"fs:ejectVolume\", async (_event, volumePath: string) => {\n  try {\n    if (process.platform === \"darwin\") {\n      // macOS: Use diskutil to eject the volume\n      const volumeName = path.basename(volumePath);\n      // Use diskutil eject with the volume name\n      await execAsync(`diskutil eject \"${volumeName}\"`);\n      return { success: true };\n    } else if (process.platform === \"win32\") {\n      // Windows: Use PowerShell to eject the volume\n      const drive = volumePath[0];\n      await execAsync(\n        `powershell -Command \"(New-Object -comObject Shell.Application).Namespace(17).ParseName('${drive}:').InvokeVerb('Eject')\"`\n      );\n      return { success: true };\n    } else if (process.platform === \"linux\") {\n      // Linux: Use umount to unmount the volume\n      await execAsync(`umount \"${volumePath}\"`);\n      return { success: true };\n    }\n    return { success: false, error: \"Platform not supported\" };\n  } catch (error) {\n    return { success: false, error: String(error) };\n  }\n});\n\n// IPC handler to get audio file URL using custom protocol\nipcMain.handle(\"fs:getAudioFileUrl\", async (_event, filePath: string) => {\n  try {\n    // Verify file exists before returning URL\n    try {\n      await fs.access(filePath);\n    } catch (accessError) {\n      console.error(\"getAudioFileUrl - file does not exist:\", filePath, accessError);\n      return { success: false, error: `File not found: ${filePath}` };\n    }\n\n    // Return a custom protocol URL that will be handled by our protocol handler\n    // Encode the entire path (including leading slash for absolute paths)\n    const encodedPath = encodeURIComponent(filePath);\n    const url = `octacard-audio://${encodedPath.startsWith(\"%2F\") ? \"/\" : \"\"}${encodedPath}`;\n    console.log(\"getAudioFileUrl - file exists, returning URL:\", url, \"for path:\", filePath);\n    return { success: true, data: url };\n  } catch (error) {\n    console.error(\"getAudioFileUrl - error:\", error, \"for path:\", filePath);\n    return { success: false, error: String(error) };\n  }\n});\n\n// IPC handler to get audio file as blob data (for WaveSurfer which doesn't support custom protocols)\nipcMain.handle(\"fs:getAudioFileBlob\", async (_event, filePath: string) => {\n  try {\n    // Verify file exists and get size\n    let fileSize = 0;\n    try {\n      const stats = await fs.stat(filePath);\n      fileSize = stats.size;\n    } catch (accessError) {\n      console.error(\"getAudioFileBlob - file does not exist:\", filePath, accessError);\n      return { success: false, error: `File not found: ${filePath}` };\n    }\n\n    // Check file size - warn for very large files\n    const fileSizeMB = fileSize / (1024 * 1024);\n    if (fileSizeMB > 200) {\n      console.warn(`getAudioFileBlob - Large file detected: ${fileSizeMB.toFixed(1)}MB. This may take a while...`);\n    }\n\n    // Read file as buffer with progress logging for large files\n    console.log(\"getAudioFileBlob - Reading file:\", filePath, `(${fileSizeMB.toFixed(1)}MB)`);\n    const fileBuffer = await fs.readFile(filePath);\n    console.log(\"getAudioFileBlob - File read complete, converting to base64...\");\n    \n    // Get MIME type from extension\n    const ext = path.extname(filePath).toLowerCase();\n    const mimeTypes: Record<string, string> = {\n      \".wav\": \"audio/wav\",\n      \".aiff\": \"audio/aiff\",\n      \".aif\": \"audio/aiff\",\n      \".mp3\": \"audio/mpeg\",\n      \".flac\": \"audio/flac\",\n      \".ogg\": \"audio/ogg\",\n      \".m4a\": \"audio/mp4\",\n      \".aac\": \"audio/aac\",\n      \".wma\": \"audio/x-ms-wma\",\n    };\n    const mimeType = mimeTypes[ext] || \"audio/mpeg\";\n\n    // Convert buffer to base64 data URL\n    // For very large files, this conversion can take time\n    const base64 = fileBuffer.toString(\"base64\");\n    const dataUrl = `data:${mimeType};base64,${base64}`;\n\n    console.log(\"getAudioFileBlob - returning blob data URL for:\", filePath);\n    return { success: true, data: dataUrl };\n  } catch (error) {\n    console.error(\"getAudioFileBlob - error:\", error, \"for path:\", filePath);\n    // Provide more helpful error messages\n    if (String(error).includes(\"ETIMEDOUT\") || String(error).includes(\"timeout\")) {\n      return { success: false, error: `File read timeout. The file may be too large or inaccessible.` };\n    }\n    return { success: false, error: String(error) };\n  }\n});\n\n// Helper function to get ffmpeg path (use static binary if available, otherwise try system)\nfunction getFFmpegPath(): string | null {\n  if (ffmpegStatic) {\n    return ffmpegStatic;\n  }\n  // Fallback to system ffmpeg\n  return \"ffmpeg\";\n}\n\n// Helper function to check if ffmpeg is available\nasync function checkFFmpegAvailable(): Promise<boolean> {\n  try {\n    const ffmpegPath = getFFmpegPath();\n    if (!ffmpegPath) return false;\n    await execAsync(`\"${ffmpegPath}\" -version`);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// Helper function to get audio file sample rate using ffprobe\nasync function getAudioSampleRate(filePath: string): Promise<number | null> {\n  try {\n    const { stdout } = await execAsync(\n      `ffprobe -v error -select_streams a:0 -show_entries stream=sample_rate -of default=noprint_wrappers=1:nokey=1 \"${filePath}\"`\n    );\n    const rate = parseFloat(stdout.trim());\n    return isNaN(rate) ? null : rate;\n  } catch {\n    return null;\n  }\n}\n\nipcMain.handle(\n  \"fs:convertAndCopyFile\",\n  async (\n    _event,\n    sourcePath: string,\n    destPath: string,\n    targetSampleRate?: number,\n    sampleDepth?: string,\n    fileFormat?: string,\n    mono?: boolean,\n    normalize?: boolean\n  ) => {\n    try {\n      // Ensure destination directory exists\n      const destDir = path.dirname(destPath);\n      await fs.mkdir(destDir, { recursive: true });\n\n      // Check if ffmpeg is available\n      const ffmpegAvailable = await checkFFmpegAvailable();\n      if (!ffmpegAvailable) {\n        // Fallback: just copy the file if ffmpeg is not available\n        console.warn(\"ffmpeg not available, copying file without conversion\");\n        await fs.copyFile(sourcePath, destPath);\n        return { success: true };\n      }\n\n      // Check if conversion is needed\n      // If any conversion setting is enabled, we'll convert\n      const needsConversion = targetSampleRate || sampleDepth === \"16-bit\" || mono || normalize || fileFormat === \"WAV\";\n      if (!needsConversion) {\n        await fs.copyFile(sourcePath, destPath);\n        return { success: true };\n      }\n\n      // Get ffmpeg path\n      const ffmpegPath = getFFmpegPath();\n      if (!ffmpegPath) {\n        console.warn(\"ffmpeg path not available, copying file without conversion\");\n        await fs.copyFile(sourcePath, destPath);\n        return { success: true };\n      }\n\n      // Build ffmpeg command arguments\n      const ffmpegArgs: string[] = [\n        \"-i\",\n        sourcePath,\n        \"-y\", // Overwrite output file\n      ];\n\n      // Add sample rate conversion (always apply if targetSampleRate is set)\n      if (targetSampleRate) {\n        ffmpegArgs.push(\"-ar\", targetSampleRate.toString());\n      }\n\n      // Add mono conversion\n      if (mono) {\n        ffmpegArgs.push(\"-ac\", \"1\");\n      }\n\n      // Add normalization (loudnorm filter)\n      if (normalize) {\n        ffmpegArgs.push(\"-af\", \"loudnorm=I=-16:TP=-1.5:LRA=11\");\n      }\n\n      // Determine audio codec based on sample depth\n      let audioCodec = \"pcm_s16le\"; // Default to 16-bit\n      if (sampleDepth === \"16-bit\") {\n        audioCodec = \"pcm_s16le\";\n      } else if (sampleDepth === \"dont-change\") {\n        // Try to preserve original bit depth, but default to 16-bit for WAV\n        audioCodec = \"pcm_s16le\";\n      } else {\n        // Default to 16-bit for compatibility\n        audioCodec = \"pcm_s16le\";\n      }\n\n      // Ensure output is WAV format if fileFormat is WAV\n      // If fileFormat is \"dont-change\" but we're converting for other reasons, also convert to WAV\n      const destExt = path.extname(destPath).toLowerCase();\n      let finalDestPath = destPath;\n      if (fileFormat === \"WAV\") {\n        // Change extension to .wav when fileFormat is explicitly set to WAV\n        finalDestPath = destPath.replace(/\\.\\w+$/i, \".wav\");\n      } else if (destExt !== \".wav\") {\n        // If not WAV format specified but extension is not .wav, convert to WAV for compatibility\n        finalDestPath = destPath.replace(/\\.\\w+$/i, \".wav\");\n      }\n\n      // Add output format specification for WAV\n      if (fileFormat === \"WAV\" || destExt !== \".wav\") {\n        ffmpegArgs.push(\"-f\", \"wav\");\n      }\n\n      ffmpegArgs.push(\"-acodec\", audioCodec, finalDestPath);\n\n      // Escape paths with spaces for shell execution\n      const escapedArgs = ffmpegArgs.map((arg) => {\n        if (arg.includes(\" \") || arg.includes('\"')) {\n          return `\"${arg.replace(/\"/g, '\\\\\"')}\"`;\n        }\n        return arg;\n      });\n\n      const command = `\"${ffmpegPath}\" ${escapedArgs.join(\" \")}`;\n\n      console.log(\"Running ffmpeg command:\", command);\n      await execAsync(command);\n\n      // Update destPath if it was changed\n      if (finalDestPath !== destPath) {\n        destPath = finalDestPath;\n      }\n\n      return { success: true };\n    } catch (error) {\n      console.error(\"FFmpeg conversion error:\", error);\n      return { success: false, error: String(error) };\n    }\n  }\n);\n\n// This method will be called when Electron has finished initialization\napp.whenReady().then(() => {\n  // Helper function to get MIME type from file extension\n  function getMimeType(filePath: string): string {\n    const ext = path.extname(filePath).toLowerCase();\n    const mimeTypes: Record<string, string> = {\n      \".wav\": \"audio/wav\",\n      \".aiff\": \"audio/aiff\",\n      \".aif\": \"audio/aiff\",\n      \".mp3\": \"audio/mpeg\",\n      \".flac\": \"audio/flac\",\n      \".ogg\": \"audio/ogg\",\n      \".m4a\": \"audio/mp4\",\n      \".aac\": \"audio/aac\",\n      \".wma\": \"audio/x-ms-wma\",\n    };\n    return mimeTypes[ext] || \"audio/mpeg\";\n  }\n\n  // Register custom protocol to serve audio files with proper MIME types\n  protocol.handle(\"octacard-audio\", async (request) => {\n    try {\n      // Extract the file path from the URL\n      // URL format: octacard-audio:///encoded-path or octacard-audio://encoded-path\n      const url = new URL(request.url);\n      console.log(\"Protocol handler - request URL:\", request.url);\n      console.log(\"Protocol handler - URL pathname:\", url.pathname);\n\n      // Get the encoded path from pathname (may or may not have leading slash)\n      // If pathname starts with /, it represents the leading slash of an absolute path\n      // The rest is the encoded path\n      let encodedPath = url.pathname;\n\n      // If pathname starts with /, remove it (it's just the URL structure, not part of encoded path)\n      // The actual leading slash is encoded as %2F in the encoded path\n      if (encodedPath.startsWith(\"/\")) {\n        encodedPath = encodedPath.slice(1);\n      }\n\n      let filePath: string;\n      try {\n        filePath = decodeURIComponent(encodedPath);\n      } catch (decodeError) {\n        console.error(\"Protocol handler - decode error:\", decodeError, \"encoded path:\", encodedPath);\n        return new Response(null, { status: 404 });\n      }\n\n      // Normalize the path to handle any path issues\n      filePath = path.normalize(filePath);\n      console.log(\"Protocol handler - decoded and normalized file path:\", filePath);\n\n      // Verify the file exists\n      try {\n        await fs.access(filePath);\n      } catch (accessError) {\n        console.error(\"Protocol handler - file access error:\", accessError);\n        console.error(\"Protocol handler - attempted path:\", filePath);\n        return new Response(null, { status: 404 });\n      }\n\n      // Read the file\n      try {\n        const fileBuffer = await fs.readFile(filePath);\n        const mimeType = getMimeType(filePath);\n        console.log(\"Protocol handler - file exists, serving:\", filePath, \"MIME type:\", mimeType);\n        return new Response(fileBuffer, {\n          headers: {\n            \"Content-Type\": mimeType,\n          },\n        });\n      } catch (readError) {\n        console.error(\"Protocol handler - file read error:\", readError);\n        return new Response(null, { status: 404 });\n      }\n    } catch (error) {\n      console.error(\"Protocol handler - error:\", error, \"request URL:\", request.url);\n      return new Response(null, { status: 404 });\n    }\n  });\n\n  console.log(\"Custom protocol 'octacard-audio' registered\");\n\n  createWindow();\n\n  // Start polling for SD/CF cards every 2 seconds\n  pollInterval = setInterval(pollForCards, 2000);\n  // Initial check\n  pollForCards();\n\n  app.on(\"activate\", () => {\n    // On macOS, re-create window when dock icon is clicked\n    if (BrowserWindow.getAllWindows().length === 0) {\n      createWindow();\n    }\n  });\n});\n\n// Clean up polling interval and ensure clean exit\napp.on(\"will-quit\", () => {\n  if (pollInterval) {\n    clearInterval(pollInterval);\n    pollInterval = null;\n  }\n  // In development mode, force exit after cleanup to help debugger detach properly\n  if (process.env.NODE_ENV === \"development\") {\n    setTimeout(() => process.exit(0), 100);\n  }\n});\n\n// Quit when all windows are closed\napp.on(\"window-all-closed\", () => {\n  // Clean up polling interval\n  if (pollInterval) {\n    clearInterval(pollInterval);\n    pollInterval = null;\n  }\n\n  // On macOS, keep app running even when all windows are closed (unless debugging)\n  // In debug mode, quit to allow debugger to detach properly\n  if (process.platform !== \"darwin\" || process.env.NODE_ENV === \"development\") {\n    app.quit();\n  }\n});\n\n// Ensure clean exit when debugging\napp.on(\"before-quit\", () => {\n  if (pollInterval) {\n    clearInterval(pollInterval);\n    pollInterval = null;\n  }\n});\n\n// Handle process signals for clean shutdown\nprocess.on(\"SIGINT\", () => {\n  if (pollInterval) {\n    clearInterval(pollInterval);\n    pollInterval = null;\n  }\n  app.quit();\n  // Force exit after a short delay to ensure clean shutdown\n  setTimeout(() => process.exit(0), 100);\n});\n\nprocess.on(\"SIGTERM\", () => {\n  if (pollInterval) {\n    clearInterval(pollInterval);\n    pollInterval = null;\n  }\n  app.quit();\n  // Force exit after a short delay to ensure clean shutdown\n  setTimeout(() => process.exit(0), 100);\n});\n"],
  "mappings": "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",
  "names": ["require", "name", "relative", "normalize"]
}
